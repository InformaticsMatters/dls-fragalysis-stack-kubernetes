

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Development &mdash; Fragalysis Stack (Kubernetes)  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Deployment" href="deployment.html" />
    <link rel="prev" title="Fragalysis Stack Orchestration (Kubernetes)" href="index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Fragalysis Stack (Kubernetes)
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Development</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#fragalysis-stack-repositories">Fragalysis Stack Repositories</a></li>
<li class="toctree-l2"><a class="reference internal" href="#build-example-master">Build example (master)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#more-scenarios-here-be-dragons">More scenarios (here be Dragons)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#how-does-travis-know-which-repos-to-trigger">How does Travis know which repos to trigger?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#how-does-a-repo-know-what-container-tag-to-use">How does a repo know what container tag to use?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#how-do-i-instruct-the-downstream-to-use-may-image">How do I instruct the downstream to use may image?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#what-if-i-want-to-trigger-a-non-master-downstream-branch">What if I want to trigger a non-master downstream branch?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#i-have-a-fork-of-the-frontend-how-do-i">I have a fork of the frontend, how do I…</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#development-recommendation">Development Recommendation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#development-examples">Development Examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#developing-front-end-f-e-code-example">Developing Front-end (F/E) Code Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#developing-back-end-b-e-code-example">Developing Back-end (B/E) Code Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#developing-stack-code-example">Developing Stack Code Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#developing-everything-example">Developing Everything Example</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#impact-on-build-process-local">Impact on Build Process (Local)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="deployment.html">Deployment</a></li>
<li class="toctree-l1"><a class="reference internal" href="demo-cluster.html">Setting up the Demo cluster</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Fragalysis Stack (Kubernetes)</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Development</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/development.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="development">
<h1>Development<a class="headerlink" href="#development" title="Permalink to this headline">¶</a></h1>
<blockquote class="epigraph">
<div><p>Fragalysis Stack development procedures for Kubernetes deployment
and the role of <a class="reference external" href="https://travis-ci.org/dashboard">Travis</a> in the Fragalysis Stack <em>CI/CD</em> process.</p>
</div></blockquote>
<p>The OpenShift deployment of the Stack used <strong>Jenkins</strong> as the CI/CD build
framework, relying on the container registry and build capabilities provided
by OpenShift. Kubernetes has no registry as such and although you can install
<strong>Jenkins</strong> it’s role is diminished as it’s more of <em>White Elephant</em> than
and clear asset in Kubernetes.</p>
<p>Instead, in the Kubernetes world, without a clear industry standard merging as
a CI/CD framework, we switch to relying on <strong>Travis</strong> in order to test and build
the Stack images.</p>
<p><strong>Travis</strong> is an external cloud-based service, free for open-source projects.</p>
<p><strong>Travis</strong> is an external cloud-based service, free for open-source projects
that is mature used by many to test and build software. It is programmed
through the use of <code class="docutils literal notranslate"><span class="pre">.travis.yml</span></code> files placed in the root directory of
GitHub projects.</p>
<p>Why not use <strong>Jenkins</strong>?</p>
<ul class="simple">
<li><p><strong>Jenkins</strong> is indeed powerful but it relies on <em>Agents</em> in order to
run Jobs. Setting these agents up requires effort. <strong>Travis</strong> runs in the
cloud where it has agents, of all kinds, that are simple and easy to
configure.</p></li>
<li><p><strong>Jenkins</strong> is a complex service with a need for persistence (volumes)
that would eat away at the Kubernetes cluster in both CPU, disk and cost.
<strong>Travis</strong> does not require resources in the Kubernetes cluster</p></li>
<li><p>Job control in <strong>Jenkins</strong> is defined through the Groovy language. It’s
powerful but it’s <em>yet another language</em> and its syntax is not the easiest
to master. <strong>Travis</strong> is programmed in YAML, a syntax many are already
familiar with. It is simple, and easy to read.</p></li>
<li><p>Management and configuration of the <strong>Jenkins</strong> server is not trivial
and incurs management and maintenance costs. <strong>Travis</strong> needs no
management.</p></li>
</ul>
<div class="section" id="fragalysis-stack-repositories">
<h2>Fragalysis Stack Repositories<a class="headerlink" href="#fragalysis-stack-repositories" title="Permalink to this headline">¶</a></h2>
<p>The stack is distributed as two container images, a <em>Loader</em> and
a <em>Stack</em>. There are five GitHub repositories involved in the build of these
two images:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fragalysis</span>
<span class="n">fragalysis</span><span class="o">-</span><span class="n">backend</span>
<span class="n">fragalysis</span><span class="o">-</span><span class="n">frontend</span>
<span class="n">fragalysis</span><span class="o">-</span><span class="n">loader</span>
<span class="n">fragalysis</span><span class="o">-</span><span class="n">stack</span>
</pre></div>
</div>
<p>The by-product of each repository is: -</p>
<dl class="simple">
<dt>fragalysis</dt><dd><p>The output of the <code class="docutils literal notranslate"><span class="pre">fragalysis</span></code> repository is a small package of
Python code, written to <a class="reference external" href="https://pypi.org/project/fragalysis/">PyPI</a> when the repository is tagged. The package
is part of the <code class="docutils literal notranslate"><span class="pre">fragalysis-backend</span></code> image’s Python <em>requirements</em> <a class="footnote-reference brackets" href="#f1" id="id1">1</a>.</p>
</dd>
<dt>fragalysis-backend</dt><dd><p>The output of the <code class="docutils literal notranslate"><span class="pre">fragalysis-backend</span></code> is a container image, written to
<a class="reference external" href="https://hub.docker.com/search?q=xchem&amp;type=image">Docker Hub</a>. This image is used as a <code class="docutils literal notranslate"><span class="pre">FROM</span></code> image in both the
<em>Loader</em> and <em>Stack</em>. The backend <code class="docutils literal notranslate"><span class="pre">FROM</span></code> image is based on
<code class="docutils literal notranslate"><span class="pre">informaticsmatters/rdkit-python-debian:latest</span></code>.</p>
</dd>
<dt>fragalysis-frontend</dt><dd><p>The output of the <code class="docutils literal notranslate"><span class="pre">fragalysis-frontend</span></code> is nothing. The code is instead
<em>cloned</em> into the container image of the <code class="docutils literal notranslate"><span class="pre">fragalysis-stack</span></code> when it is
built.</p>
</dd>
<dt>fragalysis-loader</dt><dd><p>The output of the <code class="docutils literal notranslate"><span class="pre">fragalysis-loader</span></code> is a container image, written to
<a class="reference external" href="https://hub.docker.com/search?q=xchem&amp;type=image">Docker Hub</a>. It uses the image produced by the <code class="docutils literal notranslate"><span class="pre">fragalysis-backend</span></code>
as it’s <code class="docutils literal notranslate"><span class="pre">FROM</span></code> image.</p>
</dd>
<dt>fragalysis-stack</dt><dd><p>The output of the <code class="docutils literal notranslate"><span class="pre">fragalysis-stack</span></code> is a container image, written to
<a class="reference external" href="https://hub.docker.com/search?q=xchem&amp;type=image">Docker Hub</a>. Like the <em>Loader</em> it uses the image produced by the
<code class="docutils literal notranslate"><span class="pre">fragalysis-backend</span></code> as it’s <code class="docutils literal notranslate"><span class="pre">FROM</span></code> image.</p>
</dd>
</dl>
</div>
<div class="section" id="build-example-master">
<h2>Build example (master)<a class="headerlink" href="#build-example-master" title="Permalink to this headline">¶</a></h2>
<p>Let’s see how <strong>Travis</strong> works for the Fragalysis Stack by exploring
a simple example, where a user-change to a repository’s <em>master</em> branch
results in the stack being re-built, illustrated by the following diagram.</p>
<img alt="_images/frag-travis.001.png" src="_images/frag-travis.001.png" />
<p>The diagram illustrates a <em>user</em> making a change (<strong>A</strong>) to the
<code class="docutils literal notranslate"><span class="pre">master</span></code> branch of <code class="docutils literal notranslate"><span class="pre">fragalysis-backend</span></code> repository. The following steps
occur, in approximate order: -</p>
<ol class="arabic simple">
<li><p><strong>Travis</strong> detects the change and creates a server on which the build
(and testing) takes place. The result of the build is a <strong>docker push</strong>
to <a class="reference external" href="https://hub.docker.com/search?q=xchem&amp;type=image">Docker Hub</a>. The image pushed is <code class="docutils literal notranslate"><span class="pre">xchem/fragalysis-backend:latest</span></code>
where the docker <em>user</em> is <code class="docutils literal notranslate"><span class="pre">xchem</span></code>, the project is <code class="docutils literal notranslate"><span class="pre">fragalysis-backend</span></code>
and the tag is <code class="docutils literal notranslate"><span class="pre">latest</span></code> (the significance of these values will become
important later).</p></li>
<li><p>At the end of the build of <code class="docutils literal notranslate"><span class="pre">fragalysis-backend</span></code> <strong>Travis</strong> is configured
to <em>trigger</em> a build in the remote repository <code class="docutils literal notranslate"><span class="pre">fragalysis-stack</span></code> <a class="footnote-reference brackets" href="#f2" id="id2">2</a> .
There’s a new <em>backend</em> image so the stack, which depends on it, is
instructed to build.</p></li>
<li><p>As the <em>Loader</em> also depends on the output of this build <strong>Travis</strong>
also <em>triggers*</em> the <code class="docutils literal notranslate"><span class="pre">fragalysis-loader</span></code> to build.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">fragalysis-loader</span></code> <strong>Travis</strong> session (triggered by the <em>backend</em>)
builds and as its output is a container image it is pushed to Docker Hub.
The image pushed is <code class="docutils literal notranslate"><span class="pre">xchem/fragalysis-loader:latest</span></code></p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">fragalysis-stack</span></code> <strong>Travis</strong> session (triggered by the <em>backend</em>)
builds and as its output is a container image it is pushed to Docker Hub.
The image pushed is <code class="docutils literal notranslate"><span class="pre">xchem/fragalysis-stack:latest</span></code></p></li>
</ol>
</div>
<div class="section" id="more-scenarios-here-be-dragons">
<h2>More scenarios (here be Dragons)<a class="headerlink" href="#more-scenarios-here-be-dragons" title="Permalink to this headline">¶</a></h2>
<p>That’s a simplistic illustration of a <em>build chain</em> from one <code class="docutils literal notranslate"><span class="pre">master</span></code>
branch rippling through the dependent builds on the <code class="docutils literal notranslate"><span class="pre">master</span></code> branch.</p>
<p>But software development’s more complicated than just changes to the
<code class="docutils literal notranslate"><span class="pre">master</span></code> branch and, in these cases, <strong>Travis</strong> will need some help.</p>
<div class="section" id="how-does-travis-know-which-repos-to-trigger">
<h3>How does Travis know which repos to trigger?<a class="headerlink" href="#how-does-travis-know-which-repos-to-trigger" title="Permalink to this headline">¶</a></h3>
<p>This is the responsibility of the repository owner. Our <a class="reference external" href="https://github.com/InformaticsMatters/trigger-travis.git">Trigger Travis</a>
utility is used to simplify the calls the the <strong>Travis</strong> API but the
owner of each repository needs to know which repositories to trigger
and simply adds calls to the <a class="reference external" href="https://github.com/InformaticsMatters/trigger-travis.git">Trigger Travis</a> at a suitable point in their
own <code class="docutils literal notranslate"><span class="pre">.travis.yml</span></code> file.</p>
<p>The mechanism is essentially a <em>push-driven</em> trigger from <em>upstream</em> repository
to <em>downstream</em>. A <em>downstream</em> repository cannot monitor <em>upstream</em>
repositories, the author has to know which repositories depend on their code.</p>
<blockquote class="epigraph">
<div><p>Because <strong>Jenkins</strong> runs continuously it does allow Jobs to watch other
builds (Jobs) that are <em>upstream</em> and trigger <em>downstream</em> builds (Jobs).
But this advantage is considered insignificant compared to the disadvantages
(discussed earlier).</p>
</div></blockquote>
</div>
<div class="section" id="how-does-a-repo-know-what-container-tag-to-use">
<h3>How does a repo know what container tag to use?<a class="headerlink" href="#how-does-a-repo-know-what-container-tag-to-use" title="Permalink to this headline">¶</a></h3>
<p>By convention, in a CI/CD sense, automated builds on <code class="docutils literal notranslate"><span class="pre">master</span></code> produce
container images tagged <code class="docutils literal notranslate"><span class="pre">latest</span></code>. The <strong>Travis</strong> build can be easily
organised to produce a tag that is the branch name if the build is on a branch.
Branch <code class="docutils literal notranslate"><span class="pre">1-defect</span></code> might therefore produce images that are pushed to docker
using the tag <code class="docutils literal notranslate"><span class="pre">1-defect</span></code></p>
</div>
<div class="section" id="how-do-i-instruct-the-downstream-to-use-may-image">
<h3>How do I instruct the downstream to use may image?<a class="headerlink" href="#how-do-i-instruct-the-downstream-to-use-may-image" title="Permalink to this headline">¶</a></h3>
<p>In our example we’ve assumed the branch being manipulated is <code class="docutils literal notranslate"><span class="pre">master</span></code>
and in this <em>very simple</em> workflow we want all the dependent <code class="docutils literal notranslate"><span class="pre">master</span></code>
branches to build resulting in their own <code class="docutils literal notranslate"><span class="pre">latest</span></code> images.</p>
<p>But what if you’re working on a defect on the <em>backend</em>, on a branch
called <code class="docutils literal notranslate"><span class="pre">1-defect</span></code>? Do you want to trigger a rebuild of the <em>Stack</em>’s
<code class="docutils literal notranslate"><span class="pre">latest</span></code> image from <code class="docutils literal notranslate"><span class="pre">fragalysis-backend:latest</span></code>? No, you want the
stack to use <code class="docutils literal notranslate"><span class="pre">fragalysis-backend:1-defect</span></code> as its <code class="docutils literal notranslate"><span class="pre">FROM</span></code>.</p>
<p>So this is where the <a class="reference external" href="https://github.com/InformaticsMatters/trigger-travis.git">Trigger Travis</a> utility, the <strong>Travis</strong> REST API
and your <code class="docutils literal notranslate"><span class="pre">.travis.yml</span></code> file in both your <em>upstream</em> and <em>downstream</em>
repositories become a little more complex…</p>
<p>The <em>downstream</em> (Stack) repository’s <code class="docutils literal notranslate"><span class="pre">.travis.yml</span></code> file is configured to
expect a <code class="docutils literal notranslate"><span class="pre">FROM_IMAGE</span></code> environment variable, which has a default value of
<code class="docutils literal notranslate"><span class="pre">xchem/fragalysis-backend:latest</span></code> if it is not provided. All the <em>upstream</em>
repository’s <code class="docutils literal notranslate"><span class="pre">.travis.yml</span></code> has to do is ensure that it <em>injects</em> its own
value for <code class="docutils literal notranslate"><span class="pre">FROM_IMAGE</span></code>. It is able to do this because <strong>Travis</strong> triggers
allow variables to be injected into the triggered build.</p>
<p>In our case we can pass in the variable <code class="docutils literal notranslate"><span class="pre">FROM_IMAGE=xchem/fragalysis-backend:1-defect</span></code>
and the triggered build will produce for us an image based on our <code class="docutils literal notranslate"><span class="pre">1-defect</span></code>.</p>
<p>Brilliant!</p>
<p>But hold on - the stack wil be based on <code class="docutils literal notranslate"><span class="pre">1-defect</span></code> while producing
a <code class="docutils literal notranslate"><span class="pre">latest</span></code>.</p>
<p>We can add more logic to our <em>downstream</em> repository so that the tag it uses
is actually based on the tag found in the <code class="docutils literal notranslate"><span class="pre">FROM_IMAGE</span></code> value.</p>
<p>Simple … ish</p>
<dl class="simple">
<dt>But what if you forget to set the variable?</dt><dd><p>After all, when you create your <em>backend</em> branch you need to adjust your
own Travis settings to provide a value for the variable. If you forget
(and you will) you’ll end up causing a new build of <code class="docutils literal notranslate"><span class="pre">latest</span></code> in the
downstream projects that contains your (probably untested) patch. Not what
others might expect from <code class="docutils literal notranslate"><span class="pre">latest</span></code>.</p>
</dd>
</dl>
</div>
<div class="section" id="what-if-i-want-to-trigger-a-non-master-downstream-branch">
<h3>What if I want to trigger a non-master downstream branch?<a class="headerlink" href="#what-if-i-want-to-trigger-a-non-master-downstream-branch" title="Permalink to this headline">¶</a></h3>
<blockquote class="epigraph">
<div><p>That’s a very good question.</p>
</div></blockquote>
<p>If I have a <code class="docutils literal notranslate"><span class="pre">1-defect</span></code> branch in the <em>upstream</em> build and I want to trigger
the <code class="docutils literal notranslate"><span class="pre">1-defect</span></code> branch in the <em>downstream</em> project?</p>
<p>It’s solved by the <a class="reference external" href="https://github.com/InformaticsMatters/trigger-travis.git">Trigger Travis</a> utility, which allows you to pass in
a branch definition so that <strong>Travis</strong> build the branch you name rather than
the default <code class="docutils literal notranslate"><span class="pre">master</span></code>.</p>
<p>Brilliant!</p>
<p>If you’re clever enough you could even pass this value on to <em>downstreams</em>
of the <em>downstream</em>, but that doesn’t apply in our case and starts to get
complex very quickly.</p>
<dl class="simple">
<dt>But what if you forget to set the variable?</dt><dd><p>Mmmm … OK … I see a pattern emerging here.</p>
</dd>
</dl>
<p>Basically this is where it all gets rather messy, complex and complicated
and unless you are very, very disciplined in your project organisation and
development you should be treading extremely carefully.</p>
</div>
<div class="section" id="i-have-a-fork-of-the-frontend-how-do-i">
<h3>I have a fork of the frontend, how do I…<a class="headerlink" href="#i-have-a-fork-of-the-frontend-how-do-i" title="Permalink to this headline">¶</a></h3>
<p>Here we’d like changes in a branch of a fork of one repository
to trigger the build of a branch in the fork of another repository…</p>
<p><strong>STOP!</strong> It’s just getting mind-bendingly complex.</p>
<dl class="simple">
<dt>Mmmmm</dt><dd><p>We’re starting to sink deeper into a very complicated world.</p>
</dd>
</dl>
<p>Hold on - <strong>Jenkins</strong> seemed fine. Have we lost something useful?</p>
<p>Yes … but that usefulness came with significant cost: -</p>
<p><strong>Jenkins</strong> could do this easily because it was cloning the repositories and
building them, while pushing to Docker registries while armed with keys to the
xchem Docker Hub account. We had the secrets safely stored in <strong>Jenkins</strong>.
That is something we cannot achieve in the <strong>Travis</strong> world - we can;t give
everyone a key, that’s not secure.</p>
<p>Also, creating OpenShift deployments per developer and configuring Jenkins
takes several hours, probably half a day.</p>
<p>So here we have a situation that was easily solved in <strong>Jenkins</strong> and
OpenShift that becomes enormously complicated (and probably impossible or at
the very least extremely undesirable) in the <strong>Travis</strong> World.</p>
<p>It’s here we have to think about how developers develop code for the
Fragalysis Stack and Kubernetes.</p>
<p>We need an altogether simpler approach.</p>
</div>
</div>
<div class="section" id="development-recommendation">
<h2>Development Recommendation<a class="headerlink" href="#development-recommendation" title="Permalink to this headline">¶</a></h2>
<p>For the main production images for DEV (latest) and PRODUCTION (tagged) we…</p>
<ol class="arabic simple">
<li><p>…utilise <strong>Travis</strong> build triggers in the main <code class="docutils literal notranslate"><span class="pre">xchem</span></code> repositories.
The build triggers are used <em>exclusively</em> for the automatic production of
<code class="docutils literal notranslate"><span class="pre">latest</span></code> images on the <code class="docutils literal notranslate"><span class="pre">master</span></code> branch.</p></li>
<li><p>Similarly, Travis builds tagged images on the main <code class="docutils literal notranslate"><span class="pre">xchem</span></code> repositories
based on the presence of a release (or tag) in the repository.
<code class="docutils literal notranslate"><span class="pre">fragalysis-backend:1.0.0</span></code> is automatically produced when the owner
applies the tag <code class="docutils literal notranslate"><span class="pre">1.0.0</span></code> to the <code class="docutils literal notranslate"><span class="pre">fragalysis-backend</span></code> repository.</p></li>
</ol>
<p>The main stack deployment is therefore automatic, continuous, fast but,
above all, simple.</p>
<p>Individual developers…</p>
<ol class="arabic simple" start="3">
<li><p>…work on branches of the main repositories or on branches of
<em>forks</em> of the main repos.</p></li>
<li><p>No images are automatically produced from changes to branches or forks.</p></li>
<li><p>Developers are responsible for building their own container images
and for pushing them to Docker Hub. <strong>Tina</strong> working on branch <code class="docutils literal notranslate"><span class="pre">1-defect</span></code>
in a <em>fork</em> of the <code class="docutils literal notranslate"><span class="pre">fragalysis-frontend</span></code> repository is responsible
for producing the corresponding <code class="docutils literal notranslate"><span class="pre">stack</span></code> image by (ideally) also forking
and manipulating the <code class="docutils literal notranslate"><span class="pre">fragalysis-stack</span></code> repository so that it clones her
frontend code rather than the code from <code class="docutils literal notranslate"><span class="pre">xchem/fragalysis-frontend</span></code>.</p></li>
<li><p>In order to deploy their project to Kubernetes (the subject of another Guide),
users may push their container image to any Docker Hub namespace, project
or tag. <strong>Tina</strong> can push her image as <code class="docutils literal notranslate"><span class="pre">xwz/stack-tina:1-defect</span></code> if she
chooses. This works because she will have deployed her project to
Kubernetes (now a developer responsibility) configured tso her cloud
deployment’s stack should run using the image <code class="docutils literal notranslate"><span class="pre">xwz/stack-tina:1-defect</span></code>
(rather than the default <code class="docutils literal notranslate"><span class="pre">xchem/fragalysis-stack:latest</span></code>). <strong>Tina</strong>
can also select the version of the database she wants to use and the URL
of the graph database. When she’s done she destroys the Kubernetes project.</p></li>
</ol>
<p>The above places significant responsibility on the developer - they have to
create the images, they have to push them, they have to create the Kubernetes
deployments (subject of another guide) and they have to understand the build
process.</p>
<p>But, this is a significantly simpler and a relatively pain-free route to
supporting unlimited multi-developer deployments than could be achieved by
any automatic system in the timescale available.</p>
<p>After all, if you’re expect to have 20 or 30 developers all on different forks
and branches, all developing different aspects of the code, an automatic build
system would be enormously complex, fragile and costly to maintain.</p>
</div>
<div class="section" id="development-examples">
<h2>Development Examples<a class="headerlink" href="#development-examples" title="Permalink to this headline">¶</a></h2>
<p>To further illustrate the knock-on effect of the above recommendation
for individual developers, i.e. that developers are responsible for their own
container images using repository forks and branches, a few examples follow.</p>
<blockquote class="epigraph">
<div><p>The following relies on the use of standard Docker build arguments
and the ability to use build-time args in the FROM statement,
i.e. Docker v17.05 or later.</p>
</div></blockquote>
<div class="section" id="developing-front-end-f-e-code-example">
<span id="fe-example"></span><h3>Developing Front-end (F/E) Code Example<a class="headerlink" href="#developing-front-end-f-e-code-example" title="Permalink to this headline">¶</a></h3>
<p>Here you’re developing front-end code, relying on a published backend image
and the existing stack implementation.</p>
<img alt="_images/frag-travis.002.png" src="_images/frag-travis.002.png" />
<ol class="arabic simple">
<li><p>The developer <em>forks</em> <code class="docutils literal notranslate"><span class="pre">xchem/fragslysis-frontend</span></code>, into, say
<code class="docutils literal notranslate"><span class="pre">abc/fragslysis-frontend</span></code> (<strong>A</strong>)</p></li>
<li><p>The developer creates a <em>branch</em> and clones it, e.g. <code class="docutils literal notranslate"><span class="pre">1-fix</span></code>,
in order to make changes (<strong>B</strong>)</p></li>
<li><p>The developer <em>clones</em> <code class="docutils literal notranslate"><span class="pre">xchem/fragslysis-stack</span></code> (<strong>C</strong>)</p></li>
<li><p>When a stack image is to be tested the developer builds the stack
(locally) using Docker. This could be achieved through the use of a
build script <a class="footnote-reference brackets" href="#f3" id="id3">3</a>) where the developer provides a suitable set of
<em>build-args</em>, as shown (<strong>D</strong>).</p></li>
<li><p>Upon conclusion of development a <em>pull-request</em> on the f/e repository
propagates the changes back to the XChem repo.</p></li>
</ol>
<p>The produced <em>stack</em>, built from a tagged b/e and the code in
the developer’s 1-fix branch of their front-end repo fork, can then be pushed
to Docker-hub and the Kubernetes cluster triggered to pull and run
the updated code.</p>
<p>The diagram also illustrates how the XChem <code class="docutils literal notranslate"><span class="pre">DEV/latest</span></code> Fragalysis Stack
is built and deployed (automatically using Travis). This <em>official</em> stack uses
a tagged b/e image (the same version in this example) but its <em>build args</em>
(<strong>E</strong>) are such that is uses the <code class="docutils literal notranslate"><span class="pre">master</span></code> branch of the <code class="docutils literal notranslate"><span class="pre">xchem</span></code> project
as the source of the front-end code <a class="footnote-reference brackets" href="#f4" id="id4">4</a>.</p>
<p>Notes: -</p>
<ul class="simple">
<li><p>The stack image tag would, by default, be the branch or tag being built.
Travis will take care of this for official images. Users will be able to
define the <code class="docutils literal notranslate"><span class="pre">IMAGE_TAG</span></code> build argument to over-ride this behaviour.
This is essential in the example above because the user wishes to publish
<code class="docutils literal notranslate"><span class="pre">abc/fragalysis-stack:1-fix</span></code>, not <code class="docutils literal notranslate"><span class="pre">abc/fragalysis-stack:latest</span></code>.</p></li>
</ul>
</div>
<div class="section" id="developing-back-end-b-e-code-example">
<span id="be-example"></span><h3>Developing Back-end (B/E) Code Example<a class="headerlink" href="#developing-back-end-b-e-code-example" title="Permalink to this headline">¶</a></h3>
<p>Here you’re developing back-end code, relying on existing front-end and stack
implementation.</p>
<img alt="_images/frag-travis.003.png" src="_images/frag-travis.003.png" />
<p>Here, in a less cluttered diagram: -</p>
<ol class="arabic simple">
<li><p>The developer <em>forks</em> <code class="docutils literal notranslate"><span class="pre">xchem/fragslysis-backend</span></code>, into, say
<code class="docutils literal notranslate"><span class="pre">abc/fragslysis-backend</span></code> (<strong>A</strong>)</p></li>
<li><p>The developer creates a <em>branch</em> and clones it, e.g. <code class="docutils literal notranslate"><span class="pre">1-fix</span></code>,
in order to make changes (<strong>B</strong>)</p></li>
<li><p>The developer <em>clones</em> <code class="docutils literal notranslate"><span class="pre">xchem/fragslysis-stack</span></code> (<strong>C</strong>)</p></li>
<li><p>When a stack image is to be tested the developer needs to build their own
b/e image (<strong>D</strong>) (which they can optionally push to Docker hub) and then
build the stack (locally), providing suitable <em>build-args</em>, as shown
(<strong>E</strong>).</p></li>
<li><p>Upon conclusion of development a <em>pull-request</em> on the b/e repository
propagates the changes back to the XChem repo.</p></li>
</ol>
</div>
<div class="section" id="developing-stack-code-example">
<span id="stack-example"></span><h3>Developing Stack Code Example<a class="headerlink" href="#developing-stack-code-example" title="Permalink to this headline">¶</a></h3>
<p>Here you’re developing stack code, relying on a published back-end image
and front-end implementation.</p>
<img alt="_images/frag-travis.004.png" src="_images/frag-travis.004.png" />
<ol class="arabic simple">
<li><p>The developer <em>forks</em> the fragalysis stack repository (say to <code class="docutils literal notranslate"><span class="pre">abc</span></code>)
(<strong>A</strong>)</p></li>
<li><p>The developer creates a <em>branch</em> and clones it, e.g. <code class="docutils literal notranslate"><span class="pre">1-fix</span></code>,
in order to make changes (<strong>B</strong>)</p></li>
<li><p>When a stack image needs to be tested the developer needs to build their
own stack image, which is pushed to Docker hub (<strong>C</strong>) providing suitable
<em>build-args</em>, as shown (<strong>D</strong>).</p></li>
<li><p>Upon conclusion of development  a <em>pull-request</em> on the stack repository
propagates the changes back to the XChem repo.</p></li>
</ol>
</div>
<div class="section" id="developing-everything-example">
<span id="everything-example"></span><h3>Developing Everything Example<a class="headerlink" href="#developing-everything-example" title="Permalink to this headline">¶</a></h3>
<p>Here you’re developing front-end, back-end and stack code.</p>
<img alt="_images/frag-travis.005.png" src="_images/frag-travis.005.png" />
<p>This is essentially a combination of the three prior scenarios.</p>
<ol class="arabic simple">
<li><p>The developer <em>forks</em> each repository (say to <code class="docutils literal notranslate"><span class="pre">abc</span></code>) (<strong>A</strong>)</p></li>
<li><p>The developer creates a feature <em>branch</em> in each <em>fork</em> and then
clones that to make changes (<strong>B</strong>). In the diagram we have branches
<code class="docutils literal notranslate"><span class="pre">1-fix</span></code>, <code class="docutils literal notranslate"><span class="pre">2-fix</span></code> and <code class="docutils literal notranslate"><span class="pre">4-feature</span></code> for the f/e, b/e and stack
respectively.</p></li>
<li><p>When a stack is to be tested the developer first builds their own b/e
(<strong>C</strong>) using minimal build arguments <a class="footnote-reference brackets" href="#f5" id="id5">5</a>. The user then builds their own
stack, from a clone of their code branch. Here you can see the stack
is configured to use the <code class="docutils literal notranslate"><span class="pre">abc/fragalysis-backend:2-fix</span></code> image
and a clone of the f/e <code class="docutils literal notranslate"><span class="pre">1-fix</span></code> branch.</p></li>
<li><p>The pushed stack can then be deployed to the Kubernetes cluster.</p></li>
<li><p>Upon conclusion of development  <em>pull-requests</em> for b/e, f/e and stack
repositories are made in order to propagate the changes back to the XChem
repos.</p></li>
</ol>
</div>
</div>
<div class="section" id="impact-on-build-process-local">
<h2>Impact on Build Process (Local)<a class="headerlink" href="#impact-on-build-process-local" title="Permalink to this headline">¶</a></h2>
<p>The <em>fork</em>/<em>branch</em>/<em>clone</em> requirements should not impact on the <a class="reference external" href="https://github.com/pavol-brunclik-m2ms/fragalysis-frontend/tree/develop">current</a>
development approach as they’re required to sensibly develop code
cooperatively anyway.</p>
<p>The existing <strong>Background</strong>, <strong>Prerequisites</strong> and <strong>Setup</strong> do not change.</p>
<p>The <strong>Build the images locally</strong> section changes a little, depending on what
code you’re modifying. In this case we can concentrate on the
<a class="reference internal" href="#fe-example"><span class="std std-ref">Developing Front-end (F/E) Code Example</span></a> example.</p>
<p>You will build <code class="docutils literal notranslate"><span class="pre">fragalysis-backend</span></code> and the <code class="docutils literal notranslate"><span class="pre">fragalysis-loader</span></code> as you
do now.</p>
<p>As the <code class="docutils literal notranslate"><span class="pre">fragalysis-stack</span></code> will be enhanced to use Docker’s
build arguments to identify the back-end container image and the
source of the front-end code, we just need to add
a small number of build arguments.</p>
<p>Let’s assume I’ve forked the front-end code to the <code class="docutils literal notranslate"><span class="pre">alan</span></code> GitHub account
(i.e. <code class="docutils literal notranslate"><span class="pre">alan/fragalysis-frontend</span></code>). I have also made (committed and pushed)
changes to the <code class="docutils literal notranslate"><span class="pre">1-fix</span></code> branch in that fork. In order to build a stack
using my code I just need to run the following slightly modified Docker
build command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pushd</span> <span class="n">fragalysis</span><span class="o">-</span><span class="n">stack</span> <span class="o">||</span> <span class="n">exit</span>
<span class="n">docker</span> <span class="n">build</span> <span class="o">.</span> \
    <span class="o">--</span><span class="n">build</span><span class="o">-</span><span class="n">arg</span> <span class="n">FE_GIT_PROJECT</span><span class="o">=</span><span class="n">alan</span> \
    <span class="o">--</span><span class="n">build</span><span class="o">-</span><span class="n">arg</span> <span class="n">FE_GIT_PROJECT_BRANCH</span><span class="o">=</span><span class="mi">1</span><span class="o">-</span><span class="n">fix</span> \
    <span class="o">--</span><span class="n">pull</span> \
    <span class="o">-</span><span class="n">t</span> <span class="n">xchem</span><span class="o">/</span><span class="n">fragalysis</span><span class="o">-</span><span class="n">stack</span><span class="p">:</span><span class="n">latest</span>
<span class="n">popd</span> <span class="o">||</span> <span class="n">exit</span>
</pre></div>
</div>
<blockquote class="epigraph">
<div><p>I cannot (normally) push this image because I don’t have access to the <code class="docutils literal notranslate"><span class="pre">xchem</span></code>
project in Docker Hub. I can push it to my own Docker Hub project if I
re-tag the image (or just use a different tag in the first place).</p>
</div></blockquote>
<p class="rubric">Footnotes</p>
<dl class="footnote brackets">
<dt class="label" id="f1"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Publishing to PyPi does not currently result in a trigger of the
backend. It is something we can contemplate in the new development.</p>
</dd>
<dt class="label" id="f2"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>This is achieved through a POST operation to the <strong>Travis</strong> REST API
naming the <em>downstream</em> repository and passing in some extra material.</p>
</dd>
<dt class="label" id="f3"><span class="brackets"><a class="fn-backref" href="#id3">3</a></span></dt>
<dd><p>The build script will help by forcing a pull of the
dependent backend container image for example.</p>
</dd>
<dt class="label" id="f4"><span class="brackets"><a class="fn-backref" href="#id4">4</a></span></dt>
<dd><p>ideally this would actually be a tag rather than <code class="docutils literal notranslate"><span class="pre">master</span></code></p>
</dd>
<dt class="label" id="f5"><span class="brackets"><a class="fn-backref" href="#id5">5</a></span></dt>
<dd><p>Automation fo the image project from the project fork should be
possible so the user may not have to specify anything in this case.</p>
</dd>
</dl>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="deployment.html" class="btn btn-neutral float-right" title="Deployment" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral float-left" title="Fragalysis Stack Orchestration (Kubernetes)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Informatics Matters Ltd

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>