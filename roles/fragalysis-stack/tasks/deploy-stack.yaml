---

- name: Create stack media volume claim
  k8s:
    definition: "{{ lookup('template', 'pvc-media.yaml.j2') }}"
    wait: yes
    wait_timeout: "{{ wait_timeout }}"

# Best practice ... wait for the PVC to bind.
# e.g. wait until resources[0].status.phase == Bound (initially Pending)

- name: Wait for stack media volume claim to bind
  k8s_info:
    kind: PersistentVolumeClaim
    name: media
    namespace: "{{ stack_namespace }}"
  register: bind_result
  until: bind_result.resources[0].status.phase == 'Bound'
  delay: 5
  retries: "{{ (bind_timeout|int / 5)|int }}"
  when: wait_for_bind|bool

# Deploy stack secrets.
#
# These come in three forms: -
# - Secrets for the app itself (django material)
# - Secrets for the Diamond ISPyB service
# - Secrets for the xchem user

# App (django) secrets...

- name: Check django secrets
  k8s_info:
    kind: Secret
    api_version: v1
    namespace: "{{ stack_namespace }}"
    name: django
  register: s_result

- name: Set (new) django secrets
  block:

  - name: Set django secret facts (new)
    set_fact:
      stack_django_secret_key_fact: '{{ stack_django_secret_key }}'
      stack_django_superuser_password_fact: '{{ stack_django_superuser_password }}'

  - name: Write django secrets
    k8s:
      definition: "{{ lookup('template', 'secret-django.yaml.j2') }}"
      wait: yes

  when: s_result.resources|length == 0

# ISPyB secrets... (if defined and not set to 'SetMe')

- block:

  # These variables are in a vault file.
  # Make sure they exist.

  - name: Assert ISPyB secrets are defined
    assert:
      that:
      - stack_ispyb_user is defined
      - stack_ispyb_password is defined
      - stack_ispyb_host is defined
      - stack_ispyb_port is defined

  - name: Set ISPyB secret facts (new)
    set_fact:
      stack_ispyb_user_fact: '{{ stack_ispyb_user }}'
      stack_ispyb_password_fact: '{{ stack_ispyb_password }}'
      stack_ispyb_host_fact: '{{ stack_ispyb_host }}'
      stack_ispyb_port_fact: '{{ stack_ispyb_port }}'

  - name: Write ISPyB secrets
    k8s:
      definition: "{{ lookup('template', 'secret-ispyb.yaml.j2') }}"
      wait: yes

  when:
  - stack_ispyb_host is defined
  - stack_ispyb_host|string != 'SetMe'

# App (ssh) secrets... (if defined and not set to 'SetMe')

- block:

  # These variables are in a vault file.
  # Make sure they exist.

  - name: Assert xchem secrets are defined
    assert:
      that:
      - stack_ssh_host is defined
      - stack_ssh_user is defined
      - stack_ssh_password is defined
      - stack_security_connector is defined

  - name: Set ssh secret facts
    set_fact:
      stack_ssh_host_fact: '{{ stack_ssh_host }}'
      stack_ssh_user_fact: '{{ stack_ssh_user }}'
      stack_ssh_password_fact: '{{ stack_ssh_password }}'
      stack_security_connector_fact: '{{ stack_security_connector }}'

  - name: Write ssh secrets
    k8s:
      definition: "{{ lookup('template', 'secret-ssh.yaml.j2') }}"
      wait: yes

  when:
  - stack_ssh_host is defined
  - stack_ssh_host|string != 'SetMe'

# xchem secrets... (if defined and not set to 'SetMe')

- block:

  # These variables are in a vault file.
  # Make sure they exist.

  - name: Assert xchem secrets are defined
    assert:
      that:
      - stack_xchem_user is defined
      - stack_xchem_password is defined
      - stack_xchem_name is defined
      - stack_xchem_host is defined
      - stack_xchem_port is defined

  - name: Set xchem secret facts (new)
    set_fact:
      stack_xchem_user_fact: '{{ stack_xchem_user }}'
      stack_xchem_password_fact: '{{ stack_xchem_password }}'
      stack_xchem_name_fact: '{{ stack_xchem_name }}'
      stack_xchem_host_fact: '{{ stack_xchem_host }}'
      stack_xchem_port_fact: '{{ stack_xchem_port }}'

  - name: Write xchem secrets
    k8s:
      definition: "{{ lookup('template', 'secret-xchem.yaml.j2') }}"
      wait: yes

  when:
  - stack_xchem_host is defined
  - stack_xchem_host|string != 'SetMe'

# Now the stack, its service and ingress
# and give the user their stack URL.

- name: Assert stack replicas
  assert:
    that: stack_replicas|int > 0

# Set the stack hostname, which will either be just the hostname of the
# stack (if the namespace has been defined) or the hostname plus
# the user name and their chosen stack name.

- name: Set the stack's URL (developer)
  set_fact:
    stack_url: "fragalysis-{{ tower_user_name|lower }}-{{ stack_name }}.{{ stack_hostname }}"
  when: stack_is_for_developer|bool

- name: Set the stack's URL (non-developer)
  set_fact:
    stack_url: "{{ stack_hostname }}"
  when: not stack_is_for_developer|bool

- name: Deploy stack
  k8s:
    definition: "{{ lookup('template', '{{ item }}.yaml.j2') }}"
    wait: yes
  loop:
  - statefulset-stack
  - service-stack
  - ingress-stack

- name: Deploy nery
  k8s:
    definition: "{{ lookup('template', '{{ item }}.yaml.j2') }}"
    wait: yes
  loop:
  - statefulset-nery
  - service-nery
  when: stack_deploy_nery|bool

- name: Display stack URL
  debug:
    msg: Your stack URL is 'https://{{ stack_url }}'

- name: Display graph service
  debug:
    msg: The graph service is expected at '{{ graph_hostname }}'

# The stack's a StatefulSet with {{ stack_replicas }} instances.
# They are initialised one after the other from Pod 'stack-0'
# to Pod 'stack-{{ stack_replicas - 1 }}'.
# Here we wait for all of them, starting with instance 0...

- name: Wait for each new stack to become Ready
  include_tasks: wait-for-stack.yaml
  vars:
    stack_id: "{{ item }}"
  loop: "{{ range(stack_replicas|int)|list }}"

# Display helpful usage/diagnostic information.
# Repeat the stack URL as it may have been lost in
# the repeated log from the prior task.

- name: Display stack namespace
  debug:
    msg: Your stack Kubernetes namespace is '{{ stack_namespace }}'

- name: Display stack URL (again)
  debug:
    msg: Your stack URL is 'https://{{ stack_url }}'
